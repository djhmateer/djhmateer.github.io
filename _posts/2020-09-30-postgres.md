---
layout: post
title: Postgres 
description: 
menu: review
categories: postgres 
published: false 
comments: false     
sitemap: false
image: /assets/2020-02-03/40.jpg
---

<!-- ![alt text](/assets/2020-02-03/41.jpg "Choosing an image"){:width="600px"} -->

Lightweight compared to MSSQL
can install on my 1GB Linux VM

Explore - is it good enough for my application?

Licensing - not constrained by the MSSQL license

https://github.com/TardisBank/TardisBank uses it


use it with Docker locally?

## Front End

[Azure Data Studio](https://docs.microsoft.com/en-us/sql/azure-data-studio/extensions/postgres-extension?view=sql-server-ver15) with Postgres extension

## ASP.NET Core Configuration - Connection Strings

[ASP.NET Core Configuration](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1)

I would like separate db connection strings for:

- Dev
- Running tests locally and on build server
- Prod


Environment Variables

appsettings.Development.json

```yaml
# appsettings.json
{
  "AllowedHosts": "*"
}

# appsettings.Development.json
{
  "ConnectionStrings": {
    "Default": "Host=localhost;Username=alice;Password=letmein2;Database=postgrescookiedave"
  }
}

# appsettings.Production.json
{
  "ConnectionStrings": {
    "Default": "Host=localhost;Username=bob;Password=letmein3;Database=postgrescookiedave",
  }
}

```

then

```cs
public class DBTestModel : PageModel
{
    private readonly IConfiguration _configuration;
    public DBTestModel(IConfiguration configuration) => _configuration = configuration;

    public async Task OnGetAsync()
    {
        var connectionString = _configuration.GetConnectionString("Default");

        // call the service to call the db
        var employee = await Db.GetSingleEmployee(connectionString);
        // etc..

```

## Getting data strategy

I love functional programming for it's elegance and the way it pushes you towards simplicity. I've used that here to have functions with do 1 thing well, and have dependencies injected in.

However I've chosed to not use the the 3. Functional approach below as the 2. Simple Abstracted gives the same concise code.

```cs
private readonly IConfiguration _configuration;

public IList<Thing> Things { get; set; }

public DBCassiniModel(IConfiguration configuration) => _configuration = configuration;

public async Task OnGetAsync()
{
    var connectionString = _configuration.GetConnectionString("Default");

    // 1. Simple
    //using (var conn = new NpgsqlConnection(connectionString))
    //{
    //    conn.Open();
    //    var result = await conn.QueryAsync<Thing>(
    //        "SELECT id as Id, date as Date, team as Team, target as Target, title as Title, description as Description " +
    //        "FROM master_plan LIMIT 10");
    //    Things = result.ToList();
    //}o

    // 2 Simple abstracted
    var things = await Db2.GetThings(connectionString);
    Things = things.ToList();

    // 3. Functional 
    //var things = await Db3.GetThings(connectionString);
    //Things = things.ToList();
}

 public static class Db2
  {
      public static async Task<IEnumerable<Thing>> GetThings(string connectionString)
      {
          // can I do this.. are things disposed of inside a method?
          return await GetOpenConnection(connectionString)
              .QueryAsync<Thing>(
                "SELECT id as Id, date as Date, team as Team, target as Target, " +
                "title as Title, description as Description " +
                "FROM master_plan LIMIT 10");

          //using var db = GetOpenConnection(connectionString);
          //return await db.QueryAsync<Thing>("SELECT id as Id, date as Date, team as Team, target as Target, " +
          //                                  "title as Title, description as Description " +
          //                                  "FROM master_plan LIMIT 10");

      }

      public static IDbConnection GetOpenConnection(string connectionString)
      {
          var connection = new NpgsqlConnection(connectionString);
          connection.Open();
          return connection;
      }
  }

  public static class Db3
  {
      public static Task<IEnumerable<Thing>> GetThings(string connectionString)
          => WithConnection(connectionString, async conn =>
              {
                  var result = await conn.QueryAsync<Thing>(
                      "SELECT id as Id, date as Date, team as Team, target as Target, title as Title, description as Description " +
                      "FROM master_plan LIMIT 10");

                  return result;
              });


      private static async Task<T> WithConnection<T>(
          string connectionString,
          Func<IDbConnection, Task<T>> connectionFunction)
      {
          using (var conn = new NpgsqlConnection(connectionString))
          {
              conn.Open();

              return await connectionFunction(conn);
          }
      }
  }

```

