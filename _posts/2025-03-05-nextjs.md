---
layout: post
title: Next.js 
description: 
menu: review
categories: js 
published: true 
comments: false     
sitemap: false
image: /assets/2024-11-12/1.jpg
---

[![alt text](/assets/2025-03-05/2.jpg "email"){:width="700px"}](/assets/2025-03-05/2.jpg) 

A hello world Next.js application from the [https://nextjs.org/learn/](https://nextjs.org/learn/)  excellent tutorial which at it's core shows

- How to install Next.js 
- How to add new pages

## What is Next.js

- React is a JS library for building SPAs
- Next.js is a framework for React which includes routing and data fetching

Vercel make Next.js

## Week 1 thoughts

- server rendered - PHP/.NET/Python/Rails/Express
- client rendered - JS ie everything from plain old JS to jQuery (2006) then Angular (SPA 2010), React (SPA 2013)


Next.js (released in 2016) is somewhat mindbending in that it is a mix between client and server code. The default is to render on the server. Only when browser dom events are needed, is the code run on client. eg onClick events.

### Benefits of Next.js

[https://www.youtube.com/watch?v=mTz0GXj8NN0&t=100s](https://www.youtube.com/watch?v=mTz0GXj8NN0&t=100s) - Traversy Media Next.js crash course 2021.

- Easy page routing (compared with React which needs an implementation)
- Easy deployment (vercel or anywhere that has Node.js)

[https://www.youtube.com/watch?v=Y6KDk5iyrYE&t=33s](https://www.youtube.com/watch?v=Y6KDk5iyrYE&t=33s) Next.js 13 (2024)

## Install

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash

# 0.40.1 on 4th Nov 24
nvm --version

# Node.js (LTS) if 22.14.0 on 5th Mar 2025 
nvm install --lts
node --version

# 11.1.0
# **HERE - interestingly my rgb machine didn't ask to be updated and is on  10.9.2**
npm install -g npm@11.1.0
# laptop prompted to be updated
npm install -g npm@11.2.0

# 11.1.0
npm --version

# npm install -g typescript
# 5.8.2 on 5th March 2025
# tsc -v
# run TS on Node without precompile
# npm install -g tsx --verbose

# recommended alternative to npm
npm install -g pnpm


# create-next-app 15.2.2 on 14th March 25
npx create-next-app@latest foo --use-pnpm

npx create-next-app@latest next_13_crash --use-pnpm

# create next app - 15.2.1
# creates a new directory
npx create-next-app@latest nextjs-dashboard --example "https://github.com/vercel/next-learn/tree/main/dashboard/starter-example" --use-pnpm

# install
pnpm i

# DO i need to do this?
# puts links in the .bashrc
pnpm setup

# 10.5.2 to 10.6.1 on 7th March 2025
# didn't work
pnpm add -g pnpm

# restart shell after this to get onto 10.6.1
pnpm self-update


# start dev server on http://localhost:3000
pnpm run dev
pnpm dev

# do a build
pnpm run build
pnpm build
# run build app in prod mode
pnpm start

# update nextjs (if see a stale release message on dev)
# eg on 14th March 25 I was on 15.2.1 (stale)
# this update command didn't work.
pnpm add next@latest
```

[starter example on gh](https://github.com/vercel/next-learn/tree/main/dashboard/starter-example) and there is a final example there too.

[![alt text](/assets/2025-03-05/1.jpg "email")](/assets/2025-03-05/1.jpg) 

Wow 550MB in node_modules for a demo project. Controlled from `package.json`

- /app - routes... this is where mostly working from
- /app/lib - functions, data fetching
- /app/ui - UI components eg cards, tables, forms
- /public - static assets

```ts
// /app/lib/placeholder-data.ts
const invoices = [
  {
    customer_id: customers[0].id,
    amount: 15795,
    status: 'pending',
    date: '2022-12-06',
  },
  {
    customer_id: customers[1].id,
    amount: 20348,
    status: 'pending',
    date: '2022-11-14',
  },
  // ...
];
```

then
```ts
// /app/lib/definitions.ts - usually generated eg
// by ORM drizzle which auto gens types based on db schema
export type Invoice = {
  id: string;
  customer_id: string;
  amount: number;
  date: string;
  // In TypeScript, this is called a string union type.
  // It means that the "status" property can only be one of the two strings: 'pending' or 'paid'.
  status: 'pending' | 'paid';
};
```

### Layout.tsx

Let's add /app/ui/global.css to our top level component by patching into `/app/layout.tsx`


```ts
import '@/app/ui/global.css';
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

### <Image>

- prevent layout shift when images are loading
- resize images automatically to avoid shipping large images to devices with small viewport
- lazy loading
- serve images in modern formats like WebP and AVIF if browser supports 


## CH4 - page.tsx and layout.tsx

Next.js uses folders for routing structure

- /app/dashboard/page.tsx - would be a route for /dashboard. page.tsx is essentially the index page.


`.tsx` is an extension used for TypeScript files that include JSX/React components. `.jsx` is html like syntact for components like <div> and <Link> (which is a React compomemt)

```ts
// /app/dashboard/page.tsx

// export default syntax is required by Next.js for page components because
// Next.js needs to know which component is the main component for this page route
export default function Page() {
    return <p>Dashboard Page</p>;
  }
```

- layout.tsx is - special file to create UI that is shared between multiple pages

```ts
// /app/dashboard/layout.tsx

import SideNav from '@/app/ui/dashboard/sidenav';
 
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex h-screen flex-col md:flex-row md:overflow-hidden">
      <div className="w-full flex-none md:w-64">
      // SideNav component
        <SideNav />
      </div>
      <div className="flex-grow p-6 md:overflow-y-auto md:p-12">{children}</div>
    </div>
  );
}
```

A benefit of using layouts is that on navigation only the page components update whilst the layout wont re-render. This is called `partial rendering`

complexity - am not happy with the complexity of the example, although I can see it is demonstrating abstractions.

- /app/dashboard/layout.tsx
- /app/ui/dashboard/sidenav.tsx
- navlinks.tsx - uses map reduce to render links from a js array (could be db got)


**TODO - refactor the example
- delve into server side renders vs client side renders - can I favour server side, and only do client side when totally necessary?


## CH5 - Navigating between Pages

`<Link>` component allosed you do do client side navigation with JavaScript.

eg

```ts
// /app/ui/dashboard/sidenav.tsx
import {
  UserGroupIcon,
  HomeIcon,
  DocumentDuplicateIcon,
} from '@heroicons/react/24/outline';

// Map of links to display in the side navigation.
// Depending on the size of the application, this would be stored in a database.
const links = [
  { name: 'Home', href: '/dashboard', icon: HomeIcon },
  { name: 'Invoices', href: '/dashboard/invoices', icon: DocumentDuplicateIcon },
  { name: 'Customers', href: '/dashboard/customers', icon: UserGroupIcon },
];

export default function NavLinks() {
  return (
    <>
      {links.map((link) => {
        const LinkIcon = link.icon;
        return (
          <a
            key={link.name}
            href={link.href}
            className="flex h-[48px] grow items-center justify-center gap-2 
                     rounded-md bg-gray-50 p-3 text-sm font-medium 
                     hover:bg-sky-100 hover:text-blue-600 
                     md:flex-none md:justify-start md:p-2 md:px-3"
          >
            <LinkIcon className="w-6" />
            <p className="hidden md:block">{link.name}</p>
          </a>
        );
      })}
    </>
  );
}
```

and now using the <Link /> component:

```ts
import Link from 'next/link';

<Link
 ...
 </Link>
```
- Next.js splits the application by route segments.
- it wont load all application code on initial page load
- so if a page throws an error, other pages should work
- When <Link> components appear in viewport, Next.js prefetches the code for the linked route. So when a user clicks it should be instant


### Client Component

```ts
// /app/ui/dashboard/nev-links.tsx
// this is a client component as we're using a React hook - usePathname()
'use client';

import {
  UserGroupIcon,
  HomeIcon,
  DocumentDuplicateIcon,
} from '@heroicons/react/24/outline';
import Link from 'next/link';
// use ReactHook on client side to get path from browser url
import { usePathname } from 'next/navigation';
// conditionally apply class names
import clsx from 'clsx';

// Map of links to display in the side navigation.
// Depending on the size of the application, this would be stored in a database.
const links = [
  { name: 'Home', href: '/dashboard', icon: HomeIcon },
  { name: 'Invoices', href: '/dashboard/invoices', icon: DocumentDuplicateIcon },
  { name: 'Customers', href: '/dashboard/customers', icon: UserGroupIcon },
];

export default function NavLinks() {
  const pathname = usePathname();

  return (
    <>
      {links.map((link) => {
        const LinkIcon = link.icon;
        return (
          // <a
          <Link
            key={link.name}
            href={link.href}
            // conditionally apply class name of blue when the link is active
            className={clsx(
              'flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3',
              {
                'bg-sky-100 text-blue-600': pathname === link.href,
              },
            )}
          >
            {/* icon */}
            <LinkIcon className="w-6" />
            <p className="hidden md:block">{link.name}</p>
          </Link>
          // </a>
        );
      })}
    </>
  );
}
```

### Summary

- /app/dashboard/layout.tsx - is never refreshed as we're using <Link /> components
- /app/ui/dashboard/sidenav.tsx
- /app/ui/dashboard/navlinks.tsx - `use client` so it renders client side as we're using a react hook `usePathName`. <Link /> components so navigation happens in javascript wiht no page refresh. Uses clsx to change css class on fly for highlighted text.  Uses map reduce to render links from a js array (could be db got).

- /app/dashboard/page.tsx - server side rendered (well just that component - the navlinks are not refreshed)


**TODO - still not sure as to when `use client;` is really needed other than to use ReactHooks

 **todo - get a debugger running for Next.js in cursor.


## CH6 - Database

[https://github.com/djhmateer/nextjs-dashboard](https://github.com/djhmateer/nextjs-dashboard) - got under source control

[https://vercel.com/](https://vercel.com/) - Add New Project (I've already linked my GH account to Vercel). Deploy.

Got an error [cannot find module bcrypt](https://github.com/vercel/next.js/discussions/76822) so I changed the crypt module:

```bash
pnpm add bcryptjs

# package.json
 "bcryptjs": "^3.0.2",

# put commented out dependencies in a separate section as no comments in json
  "daveCommentedOutDependencies": {
    "bcrypt": "^5.1.1"
  },

# /app/seed/route.ts
# change crypto library
// import bcrypt from 'bcrypt';
import bcrypt from 'bcryptjs';

```

### Supabase

Region for Vercel: Washing, D.C. USA (East)

Primary Region for Supabase: East US (North Virginia)

Free plan for Supabase is

- unlimited API requests
- shared cpu
- 500MB RAM
- 50K MAU (?)
- 500MB DB Space
- 5GB bandwidth
- 1GB file storage

db name: nextjs-dashboard-postgres
environments: Production, Preview, Development

I can see [https://supabase.com/](https://supabase.com/) with a linked access token from vercel.

I ended up creating a separate account on supabase as I didn't want the token magic.

copy secrets into .env

`/app/seed/route.ts` - convention for server components to handle API routes.

```ts
// /app/seed/route.ts

// defining the GET route
export async function GET() {
  try {
    const result = await sql.begin((sql) => [
      seedUsers(),
      seedCustomers(),
      seedInvoices(),
      seedRevenue(),
    ]);

    return Response.json({ message: 'Database seeded successfully' });
  } catch (error) {
    return Response.json({ error }, { status: 500 });
  }
}
```

### Here be database dragons

So there are multiple (4) ways of connecting to Supabase that I can see, and the example led me down the wrong path.


[![alt text](/assets/2025-03-05/3.jpg "email"){:width="500px"}](/assets/2025-03-05/3.jpg) 

No idea why the seed script isn't working!

[![alt text](/assets/2025-03-05/4.jpg "email"){:width="500px"}](/assets/2025-03-05/4.jpg) 

Different errors...?

[![alt text](/assets/2025-03-05/5.jpg "email"){:width="500px"}](/assets/2025-03-05/5.jpg) 

So it seems like it partially worked, but did error. Trying to delete tables on the backend but something seems wrong (very slow to try to delete)


[![alt text](/assets/2025-03-05/6.jpg "email"){:width="500px"}](/assets/2025-03-05/6.jpg)

Cascade delete failing on Customers table with a gateway timeout. Trick was to stop the dev server (open connection stopping it?)


- customers (should have a FK to invoices)
- invoices
- revenue 
- users (has email and password in here)


[![alt text](/assets/2025-03-05/7.jpg "email"){:width="500px"}](/assets/2025-03-05/7.jpg)

Something is not happy. And we're doing multiple connections (?) transactions at the same time with async. hmm.


## Different Ways

[https://supabase.com/docs/guides/database/connecting-to-postgres](https://supabase.com/docs/guides/database/connecting-to-postgres)

- for frontend applications use the Data API (REST or GraphQL) eg supabase-js package
```ts
const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
```

- for postgres clients use a connection string

[https://supabase.com/docs/guides/platform/compute-and-disk#limits-and-constraints](https://supabase.com/docs/guides/platform/compute-and-disk#limits-and-constraints)


## DB

url - a pool?

direct_database_url - for migrations (and stuff I need in a transaction)

So I can run successfully without a transaction:

```ts
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });
// const sql = postgres(process.env.POSTGRES_URL_NON_POOLING!, { ssl: 'require' });

export async function GET() {
  // sql begin is a transaction begin
  // const result = await sql.begin((sql) => [

  // Drop all existing tables
  await sql`DROP SCHEMA public CASCADE;`;
  console.log('drop schema');

  await sql`CREATE SCHEMA public;`;
  console.log('create schema');

  let result = await sql`
    CREATE TABLE IF NOT EXISTS users (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      email TEXT NOT NULL UNIQUE,
      password TEXT NOT NULL
    );`
  console.log('users:', result);

  result = await sql`
     CREATE TABLE IF NOT EXISTS invoices (
      id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
      customer_id UUID NOT NULL,
      amount INT NOT NULL,
      status VARCHAR(255) NOT NULL,
      date DATE NOT NULL
    );`
  console.log('invoices:', result);

  return Response.json({ result });
```

## Debugging

[https://nextjs.org/docs/app/building-your-application/configuring/debugging](https://nextjs.org/docs/app/building-your-application/configuring/debugging) made me this which does work:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "npm run dev"
    },
    {
      "name": "Next.js: debug client-side",
      "type": "chrome",
      "request": "launch",
      "url": "http://localhost:3000"
    },
    {
      "name": "Next.js: debug client-side (Firefox)",
      "type": "firefox",
      "request": "launch",
      "url": "http://localhost:3000",
      "reAttach": true,
      "pathMappings": [
        {
          "url": "webpack://_N_E",
          "path": "${workspaceFolder}"
        }
      ]
    },
    {
      "name": "Next.js: debug full stack",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/node_modules/.bin/next",
      "runtimeArgs": ["--inspect"],
      "skipFiles": ["<node_internals>/**"],
      "serverReadyAction": {
        "action": "debugWithEdge",
        "killOnServerStop": true,
        "pattern": "- Local:.+(https?://.+)",
        "uriFormat": "%s",
        "webRoot": "${workspaceFolder}"
      }
    }
  ]
}
```

## Non poooling connection string

So the trick was to use a non pooling connection string for these queries which are wrapped in a transaction.

Need to restart the dev server if locked (still under transaction?)

```bash
POSTGRES_URL="postgres://postgres.[reference-id]:[password]@aws-0-us-east-1.pooler.supabase.com:6543/postgres?sslmode=require&supa=base-pooler.x"

POSTGRES_URL_NON_POOLING="postgres://postgres.[referemce-id]:[password]@aws-0-us-east-1.pooler.supabase.com:5432/postgres?sslmode=require"
```


1. Direct Connection eg 
- Next.js - DATABASE_URL=postgresql://postgres:[YOUR-PASSWORD]@db.mxtindzjnwbwykadshqj.supabase.co:5432/postgres
- .NET - "DefaultConnection": "Host=db.mxtindzjnwbwykadshqj.supabase.co;Database=postgres;Username=postgres;Password=[YOUR-PASSWORD];SSL Mode=Require;Trust Server Certificate=true"
 - long lived, persistent connections
 - each client has dedicated connection to postgres
 - not IPv4 compatible (Vercel and GH Actions are IPv4 only and may not work with direct connection

2. Transaction Pooler
- Next.js - DATABASE_URL=postgresql://postgres.mxtindzjnwbwykadshqj:[YOUR-PASSWORD]@aws-0-us-east-1.pooler.supabase.com:6543/postgres

- Ideal for stateless applications like serverless functions where each interaction is brief and isolated
- Suitable for large number of connected clients
- Pre warmned connection pool to Postgres
- IPv4 compatible

3. Session Pooler
Only recommended as alternative to Direct Connection when on IPv4 network.
- Next.js - DATABASE_URL=postgresql://postgres.mxtindzjnwbwykadshqj:[YOUR-PASSWORD]@aws-0-us-east-1.pooler.supabase.com:5432/postgres



## Other Ways To Connect

I've signed up to supabase with a normal email davemateer@gmail.com and password to learn more about it. 

**todo can I link my vercel supabase instance to my davemateer@gmail.com one?


0.Another way to connect to supabase from App Frameworks like Next.js is:

NEXT_PUBLIC_SUPABASE_URL=https://mxtindzjnwbwykadshqj.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=biglongkey
 

1.Direct - For Drizzle ORM it suggests only:

DATABASE_URL="postgresql://postgres.mxtindzjnwbwykadshqj:[YOUR-PASSWORD]@aws-0-us-east-1.pooler.supabase.com:6543/postgres"


## Restart dev server - DB Stuff

You need to restart the dev server when changing connection strings, and also messing with db related queries... can get a CONNECT_TIMEOUT

If production is hitting the same database, then I got errors on dev - CONNECT_TIMEOUT but only when I'm trying the transactional work.

Okay it all seems flakey and I don't know why.

Try again after a few minutes and it works on 1 machine, but not the other (ie dev vs prod)



## Secrets on Prod


[![alt text](/assets/2025-03-05/8.jpg "email"){:width="500px"}](/assets/2025-03-05/8.jpg) 

Secrets patched through here.


## Ch 7 - Fetching Data

[https://nextjs.org/learn/dashboard-app/fetching-data](https://nextjs.org/learn/dashboard-app/fetching-data)

In Next.js you can create API endpoints using [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) just like 

We are using [Postgres.js](https://www.npmjs.com/package/postgres) library.

```ts
// /app/seed/route.ts
// this router handler is still doing weird things with db.. ie connection timeoutouts

const sql = postgres(process.env.POSTGRES_URL_NON_POOLING!, { ssl: 'require' });
export async function GET() {
  console.log('dropping schema');
  await sql`DROP SCHEMA public CASCADE;`;
  console.log('dropped schema');

  console.log('creating schema');
  await sql`CREATE SCHEMA public;`;
  console.log('created schema');
  
  console.log('begin transaction');
  try {
    const foo = 1
    const result = await sql.begin((sql) => [
      seedUsers(),
      seedCustomers(),
      seedInvoices(),
      seedRevenue(),
    ]);
    console.log('end transaction');
    return Response.json({ message: 'Database seeded successfully' });

  } catch (error) {
    console.log('error', error);
    return Response.json({ error }, { status: 500 });
  }

```

### RevenueChart

With React Server Components (which fetches data on the server) one can query the db directly without an API layer.

[![alt text](/assets/2025-03-05/9.jpg "email"){:width="500px"}](/assets/2025-03-05/9.jpg) 

```ts
// /app/lib/data.ts - all the db connection code in here.

// notice I'm using the pooled connection string here
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });

export async function fetchRevenue() {
  try {
    const data = await sql<Revenue[]>`SELECT * FROM revenue`;

    return data;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch revenue data.');
  }
```

and the page itself, which contains React components. All server side rendered.

```ts
// /app/dashboard/page.tsx
import { fetchRevenue, fetchLatestInvoices } from '@/app/lib/data';
 
export default async function Page() {
  const revenue = await fetchRevenue();
  const latestInvoices = await fetchLatestInvoices();
  return (
    <main>
      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>
        Dashboard
      </h1>
      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
      </div>
      <div className="mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8">
        <RevenueChart revenue={revenue}  />
      </div>
    </main>
  );
}
```

and the RevenueChart React component which accepts an array of Revenue.

```ts
// /app/ui/revenue-chart.tsx
// notice the type Revenue is defined
export default async function RevenueChart({
  revenue,
}: {
  revenue: Revenue[];
}) {
  const chartHeight = 350;

  const { yAxisLabels, topLabel } = generateYAxis(revenue);

  if (!revenue || revenue.length === 0) {
    return <p className="mt-4 text-gray-400">No data available.</p>;
  }

  return (
    <div className="w-full md:col-span-4">
      <h2 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>
        Recent Revenue
      </h2>

      <div className="rounded-xl bg-gray-50 p-4">
        <div className="sm:grid-cols-13 mt-0 grid grid-cols-12 items-end gap-2 rounded-md bg-white p-4 md:gap-4">
          <div
            className="mb-6 hidden flex-col justify-between text-sm text-gray-400 sm:flex"
            style={**DELME**{ height: `${chartHeight}px` }**DELME**}
          >
            {yAxisLabels.map((label) => (
              <p key={label}>{label}</p>
            ))}
          </div>

          {revenue.map((month) => (
            <div key={month.month} className="flex flex-col items-center gap-2">
              <div
                className="w-full rounded-md bg-blue-300"
                style={**DELME**{
                  height: `$**DELME**{**DELME**(chartHeight / topLabel) * month.revenue}px`,
                }}
              ></div>
              <p className="-rotate-90 text-sm text-gray-400 sm:rotate-0">
                {month.month}
              </p>
            </div>
          ))}
        </div>
        <div className="flex items-center pb-2 pt-6">
          <CalendarIcon className="h-5 w-5 text-gray-500" />
          <h3 className="ml-2 text-sm text-gray-500 ">Last 12 months</h3>
        </div>
      </div>
    </div>
  );
}
```

and the type definition:

```ts
// /app/lib/definitions.ts
// normally created by an ORM
export type Revenue = {
  month: string;
  revenue: number;
};
```

Okay so is this really querying the db each time?

- Vercel infra is in Washington DC
- DB is in us-east-1


[![alt text](/assets/2025-03-05/10.jpg "email"){:width="500px"}](/assets/2025-03-05/10.jpg) 

On production the time is not updating... the query (or UI) is being cached.

Even a hard browser force, and a different browser (which has never been to this page) gets the old time.

This is `Static Rendering` - Next.js has prerendered to improve perf.

Dev server is fine and hits the database every time.


## Parallel Queries

```ts
// /app/lib/data.ts

export async function fetchCardData() {
  try {
    // You can probably combine these into a single SQL query
    // However, we are intentionally splitting them to demonstrate
    // how to initialize multiple queries in parallel with JS.
    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;
    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;
    const invoiceStatusPromise = sql`SELECT
         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS "paid",
         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS "pending"
         FROM invoices`;

    // Parallel data fetching - not sure if I like this.
    const data = await Promise.all([
      invoiceCountPromise,
      customerCountPromise,
      invoiceStatusPromise,
    ]);

    const numberOfInvoices = Number(data[0][0].count ?? '0');
    const numberOfCustomers = Number(data[1][0].count ?? '0');
    const totalPaidInvoices = formatCurrency(data[2][0].paid ?? '0');
    const totalPendingInvoices = formatCurrency(data[2][0].pending ?? '0');

    return {
      numberOfCustomers,
      numberOfInvoices,
      totalPaidInvoices,
      totalPendingInvoices,
    };
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch card data.');
  }
}
```

## Ch 8 - Static and Dynamic Rendering


- `Static Rendering` - data fetching and rendering happens on the server at build time or when revalidating data.
- `Dynamic Rendering` - the opposite.

```ts
// /app/lib/data.ts
// interesting 3 sec delay which shows up on dev but not prod (which is currently static rendered)
export async function fetchRevenue() {
  try {
    // Artificially delay a response for demo purposes.
    // Don't do this in production :)

    console.log('Fetching revenue data...');
    await new Promise((resolve) => setTimeout(resolve, 3000));

    const data = await sql<Revenue[]>`SELECT * FROM revenue`;

    console.log('Data fetch completed after 3 seconds.');

    return data;
  } catch (error) {
    console.error('Database Error:', error);
    throw new Error('Failed to fetch revenue data.');
  }
}
```

## Ch 9 - Streaming


[![alt text](/assets/2025-03-05/11.jpg "email"){:width="500px"}](/assets/2025-03-05/11.jpg) 

`loading.tsx` is a special Next.js file built on top of React Suspense.


`<SideNav>` is static ie there are no db connections happening.

The user doesn't have to wait for the page to finish loading before navigating aray (interruptable navigation)

```ts
// /app/dashboard/loading.tsx
export default function Loading() {
    return <div>Loading...</div>;
  }
```

or could have a skeleton component:

```ts
import DashboardSkeleton from '@/app/ui/skeletons';
 
export default function Loading() {
  return <DashboardSkeleton />;
}
```

[![alt text](/assets/2025-03-05/12.jpg "email"){:width="500px"}](/assets/2025-03-05/12.jpg) 

### (overview)

Route Group (folder with parenthesis) allows us to group `page.tsx` and `loading.tsx` together so the loading only applies to the page component. The URL structure is the same is /dashboard


### Streaming a component

So each one is independant. Use React Suspense again. But this may lead to the UI popping into the screen as it becomes ready. Could stagger them by streaming page sections.

I really don't care too much about this - want the UI to be blazing fast so none of this matters.


## Ch 10 - Partial Prerendering

The is an experimental feature on Next.js 14 (we are on 15.2.1 as of 12th March 2025)

- Server Side rendered. Static. Cached. Default in Next.js. Content generated at build time.
- Server side rendering (SSR) dynamic - not cached.
- Client side Dynamic rendering - use client. 

- Partial prerendering - a mix of both static and dynamic on the server (ignore for now)

```ts
// Server Side Rendered - Static rendered - default in Next.js
export default function Page() {
    return <p>Invoices Page</p>;
}
```
asdf

```ts
// Dynamic rendering on server
export default function Page() {
  const timestamp = new Date().toString(); 
  return ( <p>Generated at: {timestamp}</p>);
}

// Force Next.js to render dynamically and not to cache
export const dynamic = 'force-dynamic';
```
asdf

```ts
// Dynamic rendered (but on the client)
'use client';

export default function Page() {
    return <p>Invoices Page</p>;
}
```


## Ch 11 - Search and pagination

URL search params to manage search state.

```ts
// app/dashboard/invoices/page.tsx
import Search from '@/app/ui/search';
import { CreateInvoice } from '@/app/ui/invoices/buttons';
import { lusitana } from '@/app/ui/fonts';
 
export default async function Page() {
  return (
    <div className="w-full">
      <div className="flex w-full items-center justify-between">
        <h1 className={`${lusitana.className} text-2xl`}>Invoices</h1>
      </div>
      <div className="mt-4 flex items-center justify-between gap-2 md:mt-8">
        <Search placeholder="Search invoices..." />
        <CreateInvoice />
      </div>
      {/*  <Suspense key={query + currentPage} fallback={<InvoicesTableSkeleton />}>
        <Table query={query} currentPage={currentPage} />
      </Suspense> */}
      <div className="mt-5 flex w-full justify-center">
        {/* <Pagination totalPages={totalPages} /> */}
      </div>
    </div>
  );
}
```
asdf

```ts
// app/ui/search.tsx

// client side dynamic rendering
'use client';
 
import { MagnifyingGlassIcon } from '@heroicons/react/24/outline';
 
export default function Search({ placeholder }: { placeholder: string }) {
  function handleSearch(term: string) {
    console.log(term);
  }
 
  return (
    <div className="relative flex flex-1 flex-shrink-0">
      <label htmlFor="search" className="sr-only">
        Search
      </label>
      <input
        className="peer block w-full rounded-md border border-gray-200 py-[9px] pl-10 text-sm outline-2 placeholder:text-gray-500"
        placeholder={placeholder}
        onChange={(e) => {
          handleSearch(e.target.value);
        }}
      />
      <MagnifyingGlassIcon className="absolute left-3 top-1/2 h-[18px] w-[18px] -translate-y-1/2 text-gray-500 peer-focus:text-gray-900" />
    </div>
  );
}

```

now update the URL with search params

debounce library to only query db when have stopped typing


[![alt text](/assets/2025-03-05/13.jpg "email"){:width="500px"}](/assets/2025-03-05/13.jpg) 

Am getting a strange Invalid frameId for foregroup frameId: 0 hmmmmm - turns out this was lastpass in my browser. Have turned if off.

### Pagination

[![alt text](/assets/2025-03-05/14.jpg "email"){:width="500px"}](/assets/2025-03-05/14.jpg) 

Works well (for a small number of records!)






## Ch 12 - Mutating data with Server Actions

Server Actions - run async code directly on the server so don't need to create an API endpoint.

```ts
// app/dashboard/invoices/create/page.tsx

import Form from '@/app/ui/invoices/create-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchCustomers } from '@/app/lib/data';
 
export default async function Page() {
  const customers = await fetchCustomers();
 
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Create Invoice',
            href: '/dashboard/invoices/create',
            active: true,
          },
        ]}
      />
      <Form customers={customers} />
    </main>
  );
}
```

which is linked to 

```ts
// app/ui/invoices/create-form.tsx

// just a submit button on a form. - createInvoice action defined below
<form action={createInvoice}>

```

Lets create a Server Action:

```ts
// app/lib/actions.ts
// marks these functions which are used in client components as server actions
// page and create-form are server compoenents... so far.. see below perhaps?
'use server';
 
export async function createInvoice(formData: FormData) {
    const rawFormData = {
      customerId: formData.get('customerId'),
      amount: formData.get('amount'),
      status: formData.get('status'),
    };
    console.log(rawFormData);
    // amount is a string
    console.log(typeof rawFormData.amount);
  }
```

Behind the scenes Server Actions create a POST API endpoint.

[![alt text](/assets/2025-03-05/15.jpg "email"){:width="400px"}](/assets/2025-03-05/15.jpg) 

Here is the server rendering the output.

### Form Validation

Lets use [Zod](https://zod.dev/) a TypeScript validation library.

```ts
// marks these functions which are used in client components as server actions
// app/dashboard/invoices/create/page.tsx is a server component
// app/ui/invoices/create-form.tsx is a server component as not using any js hooks 
'use server';

import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import postgres from 'postgres';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });

// defining the schema for the form that matches the shape of the data in the database
const FormSchema = z.object({
  id: z.string(),
  customerId: z.string(),
  // notice - coerce.number() - converts the amount to a number
  amount: z.coerce.number(),
  status: z.enum(['pending', 'paid']),
  date: z.string(),
});
 
const CreateInvoice = FormSchema.omit({ id: true, date: true });

export async function createInvoice(formData: FormData) {
    // const rawFormData = {
    // zod to parse the form data,
    const { customerId, amount, status } = CreateInvoice.parse({
        customerId: formData.get('customerId'),
        amount: formData.get('amount'),
        status: formData.get('status'),
      });
    
    const amountInCents = amount * 100;
    // date is generated in the server component as YYYY-MM-DD
    const date = new Date().toISOString().split('T')[0];

    await sql`
        INSERT INTO invoices (customer_id, amount, status, date)
        VALUES (${customerId}, ${amountInCents}, ${status}, ${date})
    `;

    // fresh data is fetched from the database ie cache is invalidated
    revalidatePath('/dashboard/invoices');
    // redirect to the invoices page
    redirect('/dashboard/invoices');
}

```

todo - understand why I need a `use server` directive on actions.ts when create-form and page.tsx are both server components.


### Updating an invoice

Dynamic Route Segment - `app/dashboard/invoices/[id]/edit/page.tsx`

```ts
// app/ui/invoices.table.tsx
// component in here called UpdateInvoice which is a button

// app/ui/invoices/buttons.tsx
export function UpdateInvoice({ id }: { id: string }) {
  return (
    <Link
      // template literals ie enclosed in backticks - just allows expressions to be embedded
      href={`/dashboard/invoices/${id}/edit`}
      className="rounded-md border p-2 hover:bg-gray-100"
    >
      <PencilIcon className="w-5" />
    </Link>
  );
}
```

and here 

```ts
// app/dashboard/invoices/[id]/edit/page.tsx

// http://localhost:3000/dashboard/invoices/9fc443dd-c163-4469-b9b6-f61da2ef1571/edit
import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchInvoiceById, fetchCustomers } from '@/app/lib/data';
 
export default async function Page(props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const id = params.id;
  const [invoice, customers] = await Promise.all([
    fetchInvoiceById(id),
    fetchCustomers(),
  ]);
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Edit Invoice',
            href: `/dashboard/invoices/${id}/edit`,
            active: true,
          },
        ]}
      />
      <Form invoice={invoice} customers={customers} />
    </main>
  );
}
```


## Ch 13 - Error handling

Notice simple try/catch below:

```ts
// app/lib/actions.ts
// server actions called by client components

// this is the function that is called when the form is submitted
// called in the create-form action property
export async function createInvoice(formData: FormData) {
    // const rawFormData = {
    // zod to parse the form data,
    const { customerId, amount, status } = CreateInvoice.parse({
        customerId: formData.get('customerId'),
        amount: formData.get('amount'),
        status: formData.get('status'),
      });
    
    const amountInCents = amount * 100;
    // date is generated in the server component as YYYY-MM-DD
    const date = new Date().toISOString().split('T')[0];

    try {
      await sql`
        INSERT INTO invoices (customer_id, amount, status, date)
        VALUES (${customerId}, ${amountInCents}, ${status}, ${date})
      `;
    } catch (error) {
      // We'll log the error to the console for now
      console.error(error);
    }

    // fresh data is fetched from the database ie cache is invalidated
    revalidatePath('/dashboard/invoices');
    // redirect to the invoices page

    // this works by throwing an error!?, so can't be inside a try catch block
    redirect('/dashboard/invoices');
}
```
and lets manually throw an error

```ts
export async function deleteInvoice(id: string) {
  throw new Error('Failed to Delete Invoice');
  
  await sql`DELETE FROM invoices WHERE id = ${id}`;
  revalidatePath('/dashboard/invoices');
}
```

### Handle errors with error.tsx


```ts
// this is a client component!
'use client';
 
// useEffect is a React hook that allows a function to be called when a component is rendered
import { useEffect } from 'react';
 
// component accepts 2 props
// error - an instance of JavaScript Error object
// reset - when executed the fundtion will try to re-render the route segment
export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Optionally log the error to an error reporting service
    console.error(error);
  }, [error]);
 
  return (
    <main className="flex h-full flex-col items-center justify-center">
      <h2 className="text-center">Something went wrong!</h2>
      <button
        className="mt-4 rounded-md bg-blue-500 px-4 py-2 text-sm text-white transition-colors hover:bg-blue-400"
        onClick={
          // Attempt to recover by trying to re-render the invoices route
          () => reset()
        }
      >
        Try again
      </button>
    </main>
  );
}
```

Hmm - this does seem complex. Nice feature I guess.

[![alt text](/assets/2025-03-05/16.jpg "email"){:width="500px"}](/assets/2025-03-05/16.jpg) 

The catch all error handler worked for `/dashboard/invoices` route.

### 404 errors with notFound function

A working UUID: http://localhost:3000/dashboard/invoices/65e7d2fb-5daa-4308-8ab6-4639bcfbb39f/edit


[![alt text](/assets/2025-03-05/17.jpg "email"){:width="500px"}](/assets/2025-03-05/17.jpg) 

A bogus UUID: http://localhost:3000/dashboard/invoices/2e94d1ed-d220-449f-9f11-f0bbceed9645/edit

The same bogus UUID on my live server:
[nextjs-dashboard-livid-zeta-60.vercel.app/dashboard/invoices/2e94d1ed-d220-449f-9f11-f0bbceed9645/edit](https://nextjs-dashboard-livid-zeta-60.vercel.app/dashboard/invoices/2e94d1ed-d220-449f-9f11-f0bbceed9645/edit)

```tsx
// app/dashboard/invoices/[id]/edit/page.tsx

import Form from '@/app/ui/invoices/edit-form';
import Breadcrumbs from '@/app/ui/invoices/breadcrumbs';
import { fetchInvoiceById, fetchCustomers } from '@/app/lib/data';
import { notFound } from 'next/navigation';
 
export default async function Page(props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const id = params.id;
  const [invoice, customers] = await Promise.all([
    fetchInvoiceById(id),
    fetchCustomers(),
  ]);

  if (!invoice) {
    notFound();
  }
  
  return (
    <main>
      <Breadcrumbs
        breadcrumbs={[
          { label: 'Invoices', href: '/dashboard/invoices' },
          {
            label: 'Edit Invoice',
            href: `/dashboard/invoices/${id}/edit`,
            active: true,
          },
        ]}
      />
      <Form invoice={invoice} customers={customers} />
    </main>
  );
}
```

and

```ts
// app/dashboard/invoices/[id]/edit/not-found.tsx
import Link from 'next/link';
import { FaceFrownIcon } from '@heroicons/react/24/outline';
 
export default function NotFound() {
  return (
    <main className="flex h-full flex-col items-center justify-center gap-2">
      <FaceFrownIcon className="w-10 text-gray-400" />
      <h2 className="text-xl font-semibold">404 Not Found</h2>
      <p>Could not find the requested invoice.</p>
      <Link
        href="/dashboard/invoices"
        className="mt-4 rounded-md bg-blue-500 px-4 py-2 text-sm text-white transition-colors hover:bg-blue-400"
      >
        Go Back
      </Link>
    </main>
  );
}
```

This 404 `not-found.tsx` page takes precedence over the 500 `error.tsx` page.






## Ch 14 - Accessibility - form validation

asdf


## Ch 15 - Authentication and Authorisation

asdf


## Ch 16 - Metadata

asdf

TODO

put a ton of records in the db - eg invoices to see how it copes.. db connetion issues. timeouts. Also search and pagination.


## Traversy Node 13

[https://www.youtube.com/watch?v=Y6KDk5iyrYE&t=33s](https://www.youtube.com/watch?v=Y6KDk5iyrYE&t=33s)

```bash
npx create-next-app@latest next_13_crash --use-pnpm
# no TypeScript
# no ESLint
# yes Tailwind (this is new is 15)
# no src directory
# yes AppRouter (new in 15)
# yes TurboPack for next dev (new in 15)
# no to customise - import alias as default (hmm default was yes to customise)
```

he is using JavaScript, and plain CSS.

Nice paired down example

Naming style of adding AboutPage or HomePage on React component - Page suffix

Showing routing by using links.
<Link>

           
